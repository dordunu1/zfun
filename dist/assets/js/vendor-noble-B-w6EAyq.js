function yt(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function kt(n,...e){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(n.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${n.length}`)}function me(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");yt(n.outputLen),yt(n.blockLen)}function at(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function Qt(n,e){kt(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const xt=BigInt(2**32-1),vt=BigInt(32);function Jt(n,e=!1){return e?{h:Number(n&xt),l:Number(n>>vt&xt)}:{h:Number(n>>vt&xt)|0,l:Number(n&xt)|0}}function te(n,e=!1){let t=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let s=0;s<n.length;s++){const{h:o,l:i}=Jt(n[s],e);[t[s],r[s]]=[o,i]}return[t,r]}const Ee=(n,e)=>BigInt(n>>>0)<<vt|BigInt(e>>>0),Be=(n,e,t)=>n>>>t,Ae=(n,e,t)=>n<<32-t|e>>>t,Se=(n,e,t)=>n>>>t|e<<32-t,Ie=(n,e,t)=>n<<32-t|e>>>t,He=(n,e,t)=>n<<64-t|e>>>t-32,Le=(n,e,t)=>n>>>t-32|e<<64-t,ve=(n,e)=>e,Oe=(n,e)=>n,ee=(n,e,t)=>n<<t|e>>>32-t,ne=(n,e,t)=>e<<t|n>>>32-t,re=(n,e,t)=>e<<t-32|n>>>64-t,se=(n,e,t)=>n<<t-32|e>>>64-t;function Ue(n,e,t,r){const s=(e>>>0)+(r>>>0);return{h:n+t+(s/2**32|0)|0,l:s|0}}const Ne=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),_e=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,ke=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),Te=(n,e,t,r,s)=>e+t+r+s+(n/2**32|0)|0,qe=(n,e,t,r,s)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),$e=(n,e,t,r,s,o)=>e+t+r+s+o+(n/2**32|0)|0,H={fromBig:Jt,split:te,toBig:Ee,shrSH:Be,shrSL:Ae,rotrSH:Se,rotrSL:Ie,rotrBH:He,rotrBL:Le,rotr32H:ve,rotr32L:Oe,rotlSH:ee,rotlSL:ne,rotlBH:re,rotlBL:se,add:Ue,add3L:Ne,add3H:_e,add4L:ke,add4H:Te,add5H:$e,add5L:qe},St=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const oe=n=>n instanceof Uint8Array,Ce=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),It=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),Y=(n,e)=>n<<32-e|n>>>e,Re=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Re)throw new Error("Non little-endian hardware is not supported");function Ze(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function mt(n){if(typeof n=="string"&&(n=Ze(n)),!oe(n))throw new Error(`expected Uint8Array, got ${typeof n}`);return n}function Ve(...n){const e=new Uint8Array(n.reduce((r,s)=>r+s.length,0));let t=0;return n.forEach(r=>{if(!oe(r))throw new Error("Uint8Array expected");e.set(r,t),t+=r.length}),e}class Tt{clone(){return this._cloneInto()}}function qt(n){const e=r=>n().update(mt(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function ze(n=32){if(St&&typeof St.getRandomValues=="function")return St.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}const[ie,ce,fe]=[[],[],[]],Fe=BigInt(0),bt=BigInt(1),Ge=BigInt(2),je=BigInt(7),Me=BigInt(256),De=BigInt(113);for(let n=0,e=bt,t=1,r=0;n<24;n++){[t,r]=[r,(2*t+3*r)%5],ie.push(2*(5*r+t)),ce.push((n+1)*(n+2)/2%64);let s=Fe;for(let o=0;o<7;o++)e=(e<<bt^(e>>je)*De)%Me,e&Ge&&(s^=bt<<(bt<<BigInt(o))-bt);fe.push(s)}const[Ye,Ke]=te(fe,!0),jt=(n,e,t)=>t>32?re(n,e,t):ee(n,e,t),Mt=(n,e,t)=>t>32?se(n,e,t):ne(n,e,t);function We(n,e=24){const t=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let i=0;i<10;i++)t[i]=n[i]^n[i+10]^n[i+20]^n[i+30]^n[i+40];for(let i=0;i<10;i+=2){const c=(i+8)%10,f=(i+2)%10,a=t[f],b=t[f+1],l=jt(a,b,1)^t[c],y=Mt(a,b,1)^t[c+1];for(let B=0;B<50;B+=10)n[i+B]^=l,n[i+B+1]^=y}let s=n[2],o=n[3];for(let i=0;i<24;i++){const c=ce[i],f=jt(s,o,c),a=Mt(s,o,c),b=ie[i];s=n[b],o=n[b+1],n[b]=f,n[b+1]=a}for(let i=0;i<50;i+=10){for(let c=0;c<10;c++)t[c]=n[i+c];for(let c=0;c<10;c++)n[i+c]^=~t[(c+2)%10]&t[(c+4)%10]}n[0]^=Ye[r],n[1]^=Ke[r]}t.fill(0)}class $t extends Tt{constructor(e,t,r,s=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=s,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,yt(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Ce(this.state)}keccak(){We(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){at(this);const{blockLen:t,state:r}=this;e=mt(e);const s=e.length;for(let o=0;o<s;){const i=Math.min(t-this.pos,s-o);for(let c=0;c<i;c++)r[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:s}=this;e[r]^=t,t&128&&r===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){at(this,!1),kt(e),this.finish();const t=this.state,{blockLen:r}=this;for(let s=0,o=e.length;s<o;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,o-s);e.set(t.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return yt(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Qt(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:s,rounds:o,enableXOF:i}=this;return e||(e=new $t(t,r,s,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=r,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const Pe=(n,e,t)=>qt(()=>new $t(e,n,t)),Vn=Pe(1,136,256/8);function Xe(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),c=Number(t&o),f=r?4:0,a=r?0:4;n.setUint32(e+f,i,r),n.setUint32(e+a,c,r)}class ae extends Tt{constructor(e,t,r,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=It(this.buffer)}update(e){at(this);const{view:t,buffer:r,blockLen:s}=this;e=mt(e);const o=e.length;for(let i=0;i<o;){const c=Math.min(s-this.pos,o-i);if(c===s){const f=It(e);for(;s<=o-i;i+=s)this.process(f,i);continue}r.set(e.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){at(this),Qt(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(r,0),i=0);for(let l=i;l<s;l++)t[l]=0;Xe(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=It(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,b=this.get();if(a>b.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)c.setUint32(4*l,b[l],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:o,destroyed:i,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(r),e}}const Qe=(n,e,t)=>n&e^~n&t,Je=(n,e,t)=>n&e^n&t^e&t,tn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Q=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),J=new Uint32Array(64);class en extends ae{constructor(){super(64,32,8,!1),this.A=Q[0]|0,this.B=Q[1]|0,this.C=Q[2]|0,this.D=Q[3]|0,this.E=Q[4]|0,this.F=Q[5]|0,this.G=Q[6]|0,this.H=Q[7]|0}get(){const{A:e,B:t,C:r,D:s,E:o,F:i,G:c,H:f}=this;return[e,t,r,s,o,i,c,f]}set(e,t,r,s,o,i,c,f){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=c|0,this.H=f|0}process(e,t){for(let l=0;l<16;l++,t+=4)J[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){const y=J[l-15],B=J[l-2],x=Y(y,7)^Y(y,18)^y>>>3,h=Y(B,17)^Y(B,19)^B>>>10;J[l]=h+J[l-7]+x+J[l-16]|0}let{A:r,B:s,C:o,D:i,E:c,F:f,G:a,H:b}=this;for(let l=0;l<64;l++){const y=Y(c,6)^Y(c,11)^Y(c,25),B=b+y+Qe(c,f,a)+tn[l]+J[l]|0,h=(Y(r,2)^Y(r,13)^Y(r,22))+Je(r,s,o)|0;b=a,a=f,f=c,c=i+B|0,i=o,o=s,s=r,r=B+h|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,a=a+this.G|0,b=b+this.H|0,this.set(r,s,o,i,c,f,a,b)}roundClean(){J.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const nn=qt(()=>new en);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const le=BigInt(0),Et=BigInt(1),rn=BigInt(2),Bt=n=>n instanceof Uint8Array,sn=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function lt(n){if(!Bt(n))throw new Error("Uint8Array expected");let e="";for(let t=0;t<n.length;t++)e+=sn[n[t]];return e}function he(n){const e=n.toString(16);return e.length&1?`0${e}`:e}function Ct(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}function ht(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const t=new Uint8Array(e/2);for(let r=0;r<t.length;r++){const s=r*2,o=n.slice(s,s+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");t[r]=i}return t}function ot(n){return Ct(lt(n))}function Rt(n){if(!Bt(n))throw new Error("Uint8Array expected");return Ct(lt(Uint8Array.from(n).reverse()))}function ut(n,e){return ht(n.toString(16).padStart(e*2,"0"))}function Zt(n,e){return ut(n,e).reverse()}function on(n){return ht(he(n))}function j(n,e,t){let r;if(typeof e=="string")try{r=ht(e)}catch(o){throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${o}`)}else if(Bt(e))r=Uint8Array.from(e);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(`${n} expected ${t} bytes, got ${s}`);return r}function gt(...n){const e=new Uint8Array(n.reduce((r,s)=>r+s.length,0));let t=0;return n.forEach(r=>{if(!Bt(r))throw new Error("Uint8Array expected");e.set(r,t),t+=r.length}),e}function cn(n,e){if(n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function fn(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function an(n){let e;for(e=0;n>le;n>>=Et,e+=1);return e}function ln(n,e){return n>>BigInt(e)&Et}const hn=(n,e,t)=>n|(t?Et:le)<<BigInt(e),Vt=n=>(rn<<BigInt(n-1))-Et,Ht=n=>new Uint8Array(n),Dt=n=>Uint8Array.from(n);function ue(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=Ht(n),s=Ht(n),o=0;const i=()=>{r.fill(1),s.fill(0),o=0},c=(...l)=>t(s,r,...l),f=(l=Ht())=>{s=c(Dt([0]),l),r=c(),l.length!==0&&(s=c(Dt([1]),l),r=c())},a=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const y=[];for(;l<e;){r=c();const B=r.slice();y.push(B),l+=r.length}return gt(...y)};return(l,y)=>{i(),f(l);let B;for(;!(B=y(a()));)f();return i(),B}}const un={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||n instanceof Uint8Array,isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function wt(n,e,t={}){const r=(s,o,i)=>{const c=un[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const f=n[s];if(!(i&&f===void 0)&&!c(f,n))throw new Error(`Invalid param ${String(s)}=${f} (${typeof f}), expected ${o}`)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(t))r(s,o,!0);return n}const dn=Object.freeze(Object.defineProperty({__proto__:null,bitGet:ln,bitLen:an,bitMask:Vt,bitSet:hn,bytesToHex:lt,bytesToNumberBE:ot,bytesToNumberLE:Rt,concatBytes:gt,createHmacDrbg:ue,ensureBytes:j,equalBytes:cn,hexToBytes:ht,hexToNumber:Ct,numberToBytesBE:ut,numberToBytesLE:Zt,numberToHexUnpadded:he,numberToVarBytesBE:on,utf8ToBytes:fn,validateObject:wt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),T=BigInt(1),rt=BigInt(2),bn=BigInt(3),Ot=BigInt(4),Yt=BigInt(5),Kt=BigInt(8);BigInt(9);BigInt(16);function Z(n,e){const t=n%e;return t>=C?t:e+t}function gn(n,e,t){if(t<=C||e<C)throw new Error("Expected power/modulo > 0");if(t===T)return C;let r=T;for(;e>C;)e&T&&(r=r*n%t),n=n*n%t,e>>=T;return r}function F(n,e,t){let r=n;for(;e-- >C;)r*=r,r%=t;return r}function Ut(n,e){if(n===C||e<=C)throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);let t=Z(n,e),r=e,s=C,o=T;for(;t!==C;){const c=r/t,f=r%t,a=s-o*c;r=t,t=f,s=o,o=a}if(r!==T)throw new Error("invert: does not exist");return Z(s,e)}function wn(n){const e=(n-T)/rt;let t,r,s;for(t=n-T,r=0;t%rt===C;t/=rt,r++);for(s=rt;s<n&&gn(s,e,n)!==n-T;s++);if(r===1){const i=(n+T)/Ot;return function(f,a){const b=f.pow(a,i);if(!f.eql(f.sqr(b),a))throw new Error("Cannot find square root");return b}}const o=(t+T)/rt;return function(c,f){if(c.pow(f,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,b=c.pow(c.mul(c.ONE,s),t),l=c.pow(f,o),y=c.pow(f,t);for(;!c.eql(y,c.ONE);){if(c.eql(y,c.ZERO))return c.ZERO;let B=1;for(let h=c.sqr(y);B<a&&!c.eql(h,c.ONE);B++)h=c.sqr(h);const x=c.pow(b,T<<BigInt(a-B-1));b=c.sqr(x),l=c.mul(l,x),y=c.mul(y,b),a=B}return l}}function pn(n){if(n%Ot===bn){const e=(n+T)/Ot;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(n%Kt===Yt){const e=(n-Yt)/Kt;return function(r,s){const o=r.mul(s,rt),i=r.pow(o,e),c=r.mul(s,i),f=r.mul(r.mul(c,rt),i),a=r.mul(c,r.sub(f,r.ONE));if(!r.eql(r.sqr(a),s))throw new Error("Cannot find square root");return a}}return wn(n)}const xn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function yn(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=xn.reduce((r,s)=>(r[s]="function",r),e);return wt(n,t)}function mn(n,e,t){if(t<C)throw new Error("Expected power > 0");if(t===C)return n.ONE;if(t===T)return e;let r=n.ONE,s=e;for(;t>C;)t&T&&(r=n.mul(r,s)),s=n.sqr(s),t>>=T;return r}function En(n,e){const t=new Array(e.length),r=e.reduce((o,i,c)=>n.is0(i)?o:(t[c]=o,n.mul(o,i)),n.ONE),s=n.inv(r);return e.reduceRight((o,i,c)=>n.is0(i)?o:(t[c]=n.mul(o,t[c]),n.mul(o,i)),s),t}function de(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Bn(n,e,t=!1,r={}){if(n<=C)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:o}=de(n,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=pn(n),c=Object.freeze({ORDER:n,BITS:s,BYTES:o,MASK:Vt(s),ZERO:C,ONE:T,create:f=>Z(f,n),isValid:f=>{if(typeof f!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);return C<=f&&f<n},is0:f=>f===C,isOdd:f=>(f&T)===T,neg:f=>Z(-f,n),eql:(f,a)=>f===a,sqr:f=>Z(f*f,n),add:(f,a)=>Z(f+a,n),sub:(f,a)=>Z(f-a,n),mul:(f,a)=>Z(f*a,n),pow:(f,a)=>mn(c,f,a),div:(f,a)=>Z(f*Ut(a,n),n),sqrN:f=>f*f,addN:(f,a)=>f+a,subN:(f,a)=>f-a,mulN:(f,a)=>f*a,inv:f=>Ut(f,n),sqrt:r.sqrt||(f=>i(c,f)),invertBatch:f=>En(c,f),cmov:(f,a,b)=>b?a:f,toBytes:f=>t?Zt(f,o):ut(f,o),fromBytes:f=>{if(f.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${f.length}`);return t?Rt(f):ot(f)}});return Object.freeze(c)}function be(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function ge(n){const e=be(n);return e+Math.ceil(e/2)}function An(n,e,t=!1){const r=n.length,s=be(e),o=ge(e);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const i=t?ot(n):Rt(n),c=Z(i,e-T)+T;return t?Zt(c,s):ut(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Sn=BigInt(0),Lt=BigInt(1);function In(n,e){const t=(s,o)=>{const i=o.negate();return s?i:o},r=s=>{const o=Math.ceil(e/s)+1,i=2**(s-1);return{windows:o,windowSize:i}};return{constTimeNegate:t,unsafeLadder(s,o){let i=n.ZERO,c=s;for(;o>Sn;)o&Lt&&(i=i.add(c)),c=c.double(),o>>=Lt;return i},precomputeWindow(s,o){const{windows:i,windowSize:c}=r(o),f=[];let a=s,b=a;for(let l=0;l<i;l++){b=a,f.push(b);for(let y=1;y<c;y++)b=b.add(a),f.push(b);a=b.double()}return f},wNAF(s,o,i){const{windows:c,windowSize:f}=r(s);let a=n.ZERO,b=n.BASE;const l=BigInt(2**s-1),y=2**s,B=BigInt(s);for(let x=0;x<c;x++){const h=x*f;let d=Number(i&l);i>>=B,d>f&&(d-=y,i+=Lt);const g=h,E=h+Math.abs(d)-1,w=x%2!==0,L=d<0;d===0?b=b.add(t(w,o[g])):a=a.add(t(L,o[E]))}return{p:a,f:b}},wNAFCached(s,o,i,c){const f=s._WINDOW_SIZE||1;let a=o.get(s);return a||(a=this.precomputeWindow(s,f),f!==1&&o.set(s,c(a))),this.wNAF(f,a,i)}}}function we(n){return yn(n.Fp),wt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...de(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Hn(n){const e=we(n);wt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=e;if(t){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Ln,hexToBytes:vn}=dn,st={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(n){const{Err:e}=st;if(n.length<2||n[0]!==2)throw new e("Invalid signature integer tag");const t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Ln(r),l:n.subarray(t+2)}},toSig(n){const{Err:e}=st,t=typeof n=="string"?vn(n):n;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let r=t.length;if(r<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=st._parseInt(t.subarray(2)),{d:i,l:c}=st._parseInt(o);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(n){const e=a=>Number.parseInt(a[0],16)&8?"00"+a:a,t=a=>{const b=a.toString(16);return b.length&1?`0${b}`:b},r=e(t(n.s)),s=e(t(n.r)),o=r.length/2,i=s.length/2,c=t(o),f=t(i);return`30${t(i+o+4)}02${f}${s}02${c}${r}`}},K=BigInt(0),G=BigInt(1);BigInt(2);const Wt=BigInt(3);BigInt(4);function On(n){const e=Hn(n),{Fp:t}=e,r=e.toBytes||((x,h,d)=>{const g=h.toAffine();return gt(Uint8Array.from([4]),t.toBytes(g.x),t.toBytes(g.y))}),s=e.fromBytes||(x=>{const h=x.subarray(1),d=t.fromBytes(h.subarray(0,t.BYTES)),g=t.fromBytes(h.subarray(t.BYTES,2*t.BYTES));return{x:d,y:g}});function o(x){const{a:h,b:d}=e,g=t.sqr(x),E=t.mul(g,x);return t.add(t.add(E,t.mul(x,h)),d)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function i(x){return typeof x=="bigint"&&K<x&&x<e.n}function c(x){if(!i(x))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(x){const{allowedPrivateKeyLengths:h,nByteLength:d,wrapPrivateKey:g,n:E}=e;if(h&&typeof x!="bigint"){if(x instanceof Uint8Array&&(x=lt(x)),typeof x!="string"||!h.includes(x.length))throw new Error("Invalid key");x=x.padStart(d*2,"0")}let w;try{w=typeof x=="bigint"?x:ot(j("private key",x,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof x}`)}return g&&(w=Z(w,E)),c(w),w}const a=new Map;function b(x){if(!(x instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(h,d,g){if(this.px=h,this.py=d,this.pz=g,h==null||!t.isValid(h))throw new Error("x required");if(d==null||!t.isValid(d))throw new Error("y required");if(g==null||!t.isValid(g))throw new Error("z required")}static fromAffine(h){const{x:d,y:g}=h||{};if(!h||!t.isValid(d)||!t.isValid(g))throw new Error("invalid affine point");if(h instanceof l)throw new Error("projective point not allowed");const E=w=>t.eql(w,t.ZERO);return E(d)&&E(g)?l.ZERO:new l(d,g,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const d=t.invertBatch(h.map(g=>g.pz));return h.map((g,E)=>g.toAffine(d[E])).map(l.fromAffine)}static fromHex(h){const d=l.fromAffine(s(j("pointHex",h)));return d.assertValidity(),d}static fromPrivateKey(h){return l.BASE.multiply(f(h))}_setWindowSize(h){this._WINDOW_SIZE=h,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:h,y:d}=this.toAffine();if(!t.isValid(h)||!t.isValid(d))throw new Error("bad point: x or y not FE");const g=t.sqr(d),E=o(h);if(!t.eql(g,E))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:h}=this.toAffine();if(t.isOdd)return!t.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){b(h);const{px:d,py:g,pz:E}=this,{px:w,py:L,pz:I}=h,m=t.eql(t.mul(d,I),t.mul(w,E)),S=t.eql(t.mul(g,I),t.mul(L,E));return m&&S}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){const{a:h,b:d}=e,g=t.mul(d,Wt),{px:E,py:w,pz:L}=this;let I=t.ZERO,m=t.ZERO,S=t.ZERO,A=t.mul(E,E),k=t.mul(w,w),U=t.mul(L,L),O=t.mul(E,w);return O=t.add(O,O),S=t.mul(E,L),S=t.add(S,S),I=t.mul(h,S),m=t.mul(g,U),m=t.add(I,m),I=t.sub(k,m),m=t.add(k,m),m=t.mul(I,m),I=t.mul(O,I),S=t.mul(g,S),U=t.mul(h,U),O=t.sub(A,U),O=t.mul(h,O),O=t.add(O,S),S=t.add(A,A),A=t.add(S,A),A=t.add(A,U),A=t.mul(A,O),m=t.add(m,A),U=t.mul(w,L),U=t.add(U,U),A=t.mul(U,O),I=t.sub(I,A),S=t.mul(U,k),S=t.add(S,S),S=t.add(S,S),new l(I,m,S)}add(h){b(h);const{px:d,py:g,pz:E}=this,{px:w,py:L,pz:I}=h;let m=t.ZERO,S=t.ZERO,A=t.ZERO;const k=e.a,U=t.mul(e.b,Wt);let O=t.mul(d,w),q=t.mul(g,L),R=t.mul(E,I),M=t.add(d,g),u=t.add(w,L);M=t.mul(M,u),u=t.add(O,q),M=t.sub(M,u),u=t.add(d,E);let p=t.add(w,I);return u=t.mul(u,p),p=t.add(O,R),u=t.sub(u,p),p=t.add(g,E),m=t.add(L,I),p=t.mul(p,m),m=t.add(q,R),p=t.sub(p,m),A=t.mul(k,u),m=t.mul(U,R),A=t.add(m,A),m=t.sub(q,A),A=t.add(q,A),S=t.mul(m,A),q=t.add(O,O),q=t.add(q,O),R=t.mul(k,R),u=t.mul(U,u),q=t.add(q,R),R=t.sub(O,R),R=t.mul(k,R),u=t.add(u,R),O=t.mul(q,u),S=t.add(S,O),O=t.mul(p,u),m=t.mul(M,m),m=t.sub(m,O),O=t.mul(M,q),A=t.mul(p,A),A=t.add(A,O),new l(m,S,A)}subtract(h){return this.add(h.negate())}is0(){return this.equals(l.ZERO)}wNAF(h){return B.wNAFCached(this,a,h,d=>{const g=t.invertBatch(d.map(E=>E.pz));return d.map((E,w)=>E.toAffine(g[w])).map(l.fromAffine)})}multiplyUnsafe(h){const d=l.ZERO;if(h===K)return d;if(c(h),h===G)return this;const{endo:g}=e;if(!g)return B.unsafeLadder(this,h);let{k1neg:E,k1:w,k2neg:L,k2:I}=g.splitScalar(h),m=d,S=d,A=this;for(;w>K||I>K;)w&G&&(m=m.add(A)),I&G&&(S=S.add(A)),A=A.double(),w>>=G,I>>=G;return E&&(m=m.negate()),L&&(S=S.negate()),S=new l(t.mul(S.px,g.beta),S.py,S.pz),m.add(S)}multiply(h){c(h);let d=h,g,E;const{endo:w}=e;if(w){const{k1neg:L,k1:I,k2neg:m,k2:S}=w.splitScalar(d);let{p:A,f:k}=this.wNAF(I),{p:U,f:O}=this.wNAF(S);A=B.constTimeNegate(L,A),U=B.constTimeNegate(m,U),U=new l(t.mul(U.px,w.beta),U.py,U.pz),g=A.add(U),E=k.add(O)}else{const{p:L,f:I}=this.wNAF(d);g=L,E=I}return l.normalizeZ([g,E])[0]}multiplyAndAddUnsafe(h,d,g){const E=l.BASE,w=(I,m)=>m===K||m===G||!I.equals(E)?I.multiplyUnsafe(m):I.multiply(m),L=w(this,d).add(w(h,g));return L.is0()?void 0:L}toAffine(h){const{px:d,py:g,pz:E}=this,w=this.is0();h==null&&(h=w?t.ONE:t.inv(E));const L=t.mul(d,h),I=t.mul(g,h),m=t.mul(E,h);if(w)return{x:t.ZERO,y:t.ZERO};if(!t.eql(m,t.ONE))throw new Error("invZ was invalid");return{x:L,y:I}}isTorsionFree(){const{h,isTorsionFree:d}=e;if(h===G)return!0;if(d)return d(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:d}=e;return h===G?this:d?d(l,this):this.multiplyUnsafe(e.h)}toRawBytes(h=!0){return this.assertValidity(),r(l,this,h)}toHex(h=!0){return lt(this.toRawBytes(h))}}l.BASE=new l(e.Gx,e.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);const y=e.nBitLength,B=In(l,e.endo?Math.ceil(y/2):y);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:f,weierstrassEquation:o,isWithinCurveOrder:i}}function Un(n){const e=we(n);return wt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Nn(n){const e=Un(n),{Fp:t,n:r}=e,s=t.BYTES+1,o=2*t.BYTES+1;function i(u){return K<u&&u<t.ORDER}function c(u){return Z(u,r)}function f(u){return Ut(u,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:b,weierstrassEquation:l,isWithinCurveOrder:y}=On({...e,toBytes(u,p,v){const _=p.toAffine(),N=t.toBytes(_.x),$=gt;return v?$(Uint8Array.from([p.hasEvenY()?2:3]),N):$(Uint8Array.from([4]),N,t.toBytes(_.y))},fromBytes(u){const p=u.length,v=u[0],_=u.subarray(1);if(p===s&&(v===2||v===3)){const N=ot(_);if(!i(N))throw new Error("Point is not on curve");const $=l(N);let V=t.sqrt($);const z=(V&G)===G;return(v&1)===1!==z&&(V=t.neg(V)),{x:N,y:V}}else if(p===o&&v===4){const N=t.fromBytes(_.subarray(0,t.BYTES)),$=t.fromBytes(_.subarray(t.BYTES,2*t.BYTES));return{x:N,y:$}}else throw new Error(`Point of length ${p} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),B=u=>lt(ut(u,e.nByteLength));function x(u){const p=r>>G;return u>p}function h(u){return x(u)?c(-u):u}const d=(u,p,v)=>ot(u.slice(p,v));class g{constructor(p,v,_){this.r=p,this.s=v,this.recovery=_,this.assertValidity()}static fromCompact(p){const v=e.nByteLength;return p=j("compactSignature",p,v*2),new g(d(p,0,v),d(p,v,2*v))}static fromDER(p){const{r:v,s:_}=st.toSig(j("DER",p));return new g(v,_)}assertValidity(){if(!y(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!y(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(p){return new g(this.r,this.s,p)}recoverPublicKey(p){const{r:v,s:_,recovery:N}=this,$=S(j("msgHash",p));if(N==null||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const V=N===2||N===3?v+e.n:v;if(V>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=N&1?"03":"02",W=a.fromHex(z+B(V)),P=f(V),it=c(-$*P),dt=c(_*P),X=a.BASE.multiplyAndAddUnsafe(W,it,dt);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return x(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return st.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return B(this.r)+B(this.s)}}const E={isValidPrivateKey(u){try{return b(u),!0}catch{return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const u=ge(e.n);return An(e.randomBytes(u),e.n)},precompute(u=8,p=a.BASE){return p._setWindowSize(u),p.multiply(BigInt(3)),p}};function w(u,p=!0){return a.fromPrivateKey(u).toRawBytes(p)}function L(u){const p=u instanceof Uint8Array,v=typeof u=="string",_=(p||v)&&u.length;return p?_===s||_===o:v?_===2*s||_===2*o:u instanceof a}function I(u,p,v=!0){if(L(u))throw new Error("first arg must be private key");if(!L(p))throw new Error("second arg must be public key");return a.fromHex(p).multiply(b(u)).toRawBytes(v)}const m=e.bits2int||function(u){const p=ot(u),v=u.length*8-e.nBitLength;return v>0?p>>BigInt(v):p},S=e.bits2int_modN||function(u){return c(m(u))},A=Vt(e.nBitLength);function k(u){if(typeof u!="bigint")throw new Error("bigint expected");if(!(K<=u&&u<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return ut(u,e.nByteLength)}function U(u,p,v=O){if(["recovered","canonical"].some(nt=>nt in v))throw new Error("sign() legacy options not supported");const{hash:_,randomBytes:N}=e;let{lowS:$,prehash:V,extraEntropy:z}=v;$==null&&($=!0),u=j("msgHash",u),V&&(u=j("prehashed msgHash",_(u)));const W=S(u),P=b(p),it=[k(P),k(W)];if(z!=null){const nt=z===!0?N(t.BYTES):z;it.push(j("extraEntropy",nt))}const dt=gt(...it),X=W;function At(nt){const ct=m(nt);if(!y(ct))return;const zt=f(ct),D=a.BASE.multiply(ct).toAffine(),ft=c(D.x);if(ft===K)return;const pt=c(zt*c(X+ft*P));if(pt===K)return;let Ft=(D.x===ft?0:2)|Number(D.y&G),Gt=pt;return $&&x(pt)&&(Gt=h(pt),Ft^=1),new g(ft,Gt,Ft)}return{seed:dt,k2sig:At}}const O={lowS:e.lowS,prehash:!1},q={lowS:e.lowS,prehash:!1};function R(u,p,v=O){const{seed:_,k2sig:N}=U(u,p,v),$=e;return ue($.hash.outputLen,$.nByteLength,$.hmac)(_,N)}a.BASE._setWindowSize(8);function M(u,p,v,_=q){const N=u;if(p=j("msgHash",p),v=j("publicKey",v),"strict"in _)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:V}=_;let z,W;try{if(typeof N=="string"||N instanceof Uint8Array)try{z=g.fromDER(N)}catch(D){if(!(D instanceof st.Err))throw D;z=g.fromCompact(N)}else if(typeof N=="object"&&typeof N.r=="bigint"&&typeof N.s=="bigint"){const{r:D,s:ft}=N;z=new g(D,ft)}else throw new Error("PARSE");W=a.fromHex(v)}catch(D){if(D.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&z.hasHighS())return!1;V&&(p=e.hash(p));const{r:P,s:it}=z,dt=S(p),X=f(it),At=c(dt*X),nt=c(P*X),ct=a.BASE.multiplyAndAddUnsafe(W,At,nt)?.toAffine();return ct?c(ct.x)===P:!1}return{CURVE:e,getPublicKey:w,getSharedSecret:I,sign:R,verify:M,ProjectivePoint:a,Signature:g,utils:E}}class pe extends Tt{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,me(e);const r=mt(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return at(this),this.iHash.update(e),this}digestInto(e){at(this),kt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:o,blockLen:i,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const xe=(n,e,t)=>new pe(n,e).update(t).digest();xe.create=(n,e)=>new pe(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _n(n){return{hash:n,hmac:(e,...t)=>xe(n,e,Ve(...t)),randomBytes:ze}}function kn(n,e){const t=r=>Nn({...n,..._n(r)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ye=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Pt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Tn=BigInt(1),Nt=BigInt(2),Xt=(n,e)=>(n+e/Nt)/e;function qn(n){const e=ye,t=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),c=BigInt(44),f=BigInt(88),a=n*n*n%e,b=a*a*n%e,l=F(b,t,e)*b%e,y=F(l,t,e)*b%e,B=F(y,Nt,e)*a%e,x=F(B,s,e)*B%e,h=F(x,o,e)*x%e,d=F(h,c,e)*h%e,g=F(d,f,e)*d%e,E=F(g,c,e)*h%e,w=F(E,t,e)*b%e,L=F(w,i,e)*x%e,I=F(L,r,e)*a%e,m=F(I,Nt,e);if(!_t.eql(_t.sqr(m),n))throw new Error("Cannot find square root");return m}const _t=Bn(ye,void 0,void 0,{sqrt:qn}),$n=kn({a:BigInt(0),b:BigInt(7),Fp:_t,n:Pt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=Pt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Tn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,i=BigInt("0x100000000000000000000000000000000"),c=Xt(o*n,e),f=Xt(-r*n,e);let a=Z(n-c*t-f*s,e),b=Z(-c*r-f*o,e);const l=a>i,y=b>i;if(l&&(a=e-a),y&&(b=e-b),a>i||b>i)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:l,k1:a,k2neg:y,k2:b}}}},nn);BigInt(0);$n.ProjectivePoint;const[Cn,Rn]=H.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),tt=new Uint32Array(80),et=new Uint32Array(80);class Zn extends ae{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:o,Cl:i,Dh:c,Dl:f,Eh:a,El:b,Fh:l,Fl:y,Gh:B,Gl:x,Hh:h,Hl:d}=this;return[e,t,r,s,o,i,c,f,a,b,l,y,B,x,h,d]}set(e,t,r,s,o,i,c,f,a,b,l,y,B,x,h,d){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=c|0,this.Dl=f|0,this.Eh=a|0,this.El=b|0,this.Fh=l|0,this.Fl=y|0,this.Gh=B|0,this.Gl=x|0,this.Hh=h|0,this.Hl=d|0}process(e,t){for(let w=0;w<16;w++,t+=4)tt[w]=e.getUint32(t),et[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const L=tt[w-15]|0,I=et[w-15]|0,m=H.rotrSH(L,I,1)^H.rotrSH(L,I,8)^H.shrSH(L,I,7),S=H.rotrSL(L,I,1)^H.rotrSL(L,I,8)^H.shrSL(L,I,7),A=tt[w-2]|0,k=et[w-2]|0,U=H.rotrSH(A,k,19)^H.rotrBH(A,k,61)^H.shrSH(A,k,6),O=H.rotrSL(A,k,19)^H.rotrBL(A,k,61)^H.shrSL(A,k,6),q=H.add4L(S,O,et[w-7],et[w-16]),R=H.add4H(q,m,U,tt[w-7],tt[w-16]);tt[w]=R|0,et[w]=q|0}let{Ah:r,Al:s,Bh:o,Bl:i,Ch:c,Cl:f,Dh:a,Dl:b,Eh:l,El:y,Fh:B,Fl:x,Gh:h,Gl:d,Hh:g,Hl:E}=this;for(let w=0;w<80;w++){const L=H.rotrSH(l,y,14)^H.rotrSH(l,y,18)^H.rotrBH(l,y,41),I=H.rotrSL(l,y,14)^H.rotrSL(l,y,18)^H.rotrBL(l,y,41),m=l&B^~l&h,S=y&x^~y&d,A=H.add5L(E,I,S,Rn[w],et[w]),k=H.add5H(A,g,L,m,Cn[w],tt[w]),U=A|0,O=H.rotrSH(r,s,28)^H.rotrBH(r,s,34)^H.rotrBH(r,s,39),q=H.rotrSL(r,s,28)^H.rotrBL(r,s,34)^H.rotrBL(r,s,39),R=r&o^r&c^o&c,M=s&i^s&f^i&f;g=h|0,E=d|0,h=B|0,d=x|0,B=l|0,x=y|0,{h:l,l:y}=H.add(a|0,b|0,k|0,U|0),a=c|0,b=f|0,c=o|0,f=i|0,o=r|0,i=s|0;const u=H.add3L(U,q,M);r=H.add3H(u,k,O,R),s=u|0}({h:r,l:s}=H.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:i}=H.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:c,l:f}=H.add(this.Ch|0,this.Cl|0,c|0,f|0),{h:a,l:b}=H.add(this.Dh|0,this.Dl|0,a|0,b|0),{h:l,l:y}=H.add(this.Eh|0,this.El|0,l|0,y|0),{h:B,l:x}=H.add(this.Fh|0,this.Fl|0,B|0,x|0),{h,l:d}=H.add(this.Gh|0,this.Gl|0,h|0,d|0),{h:g,l:E}=H.add(this.Hh|0,this.Hl|0,g|0,E|0),this.set(r,s,o,i,c,f,a,b,l,y,B,x,h,d,g,E)}roundClean(){tt.fill(0),et.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Fn=qt(()=>new Zn);export{nn as a,$n as b,cn as e,Vn as k,Fn as s};
//# sourceMappingURL=vendor-noble-B-w6EAyq.js.map
